import org.terifan.zulu.*;
import org.terifan.zulu.core.*;


public class /**value-of SHADER_NAME*/ implements PixelRenderer
{
	private final static int [] BASE2LOOKUP;
	private final static float [] DIVCONSTANTS;


	/**for-each TEXTURE*/
	private Texture2D mTexture#ID;
	/**next TEXTURE*/
	private int [] mFrameBuffer;
	private int [] mDepthBuffer;

	static
	{
		BASE2LOOKUP = new int[60000];
		for (int i = BASE2LOOKUP.length; --i > 0;)
		{
			BASE2LOOKUP[i] = (int)(Math.log(i)/Math.log(2));
		}

		DIVCONSTANTS = new float[65];
		for (int i = 0; i < DIVCONSTANTS.length; i++)
		{
			DIVCONSTANTS[i] = 1f / i;
		}
	}


	private float edgeAX, edgeADeltaX;
	private float edgeAZ, edgeADeltaZ;
	private float edgeBX, edgeBDeltaX;
	private float edgeBZ, edgeBDeltaZ;
	/**for-each TEXTURE_COORDINATE_COMPONENT*/
	private float edgeA#COMP#ID, edgeADelta#COMP#ID;
	private float edgeB#COMP#ID, edgeBDelta#COMP#ID;
	/**next TEXTURE_COORDINATE_COMPONENT*/


	/**for-each EDGE_INDEX*/
	public void initEdge#EDGE(GeometryBuffer aGeometryBuffer, int aPrimitiveIndex, int aTopVertex, int aBottomVertex, int aSkip)
	{
		float [] buffer = aGeometryBuffer.getVertexData();

		VertexFormat vertexFormat = aGeometryBuffer.getVertexFormat(aPrimitiveIndex);

		float topy = buffer[aTopVertex+1];
		float boty = buffer[aBottomVertex+1];
		float topiz = buffer[aTopVertex+2];
		float botiz = buffer[aBottomVertex+2];

		float delta = (boty == topy) ? 0f : 1f / (boty - topy);

		edge#EDGEX      =  buffer[aTopVertex   +0];
		edge#EDGEDeltaX = (buffer[aBottomVertex+0] - edge#EDGEX) * delta;

		edge#EDGEZ      =  topiz;
		edge#EDGEDeltaZ = (botiz - topiz) * delta;

		int offset = 3+vertexFormat.mColorFieldCount;

		/**for-each TEXTURE_COORDINATE_COMPONENT*/
		edge#EDGE#COMP#ID      =  topiz * mTexture#ID.maps[0].#PROP * buffer[aTopVertex   +offset+#INDEX];
		edge#EDGEDelta#COMP#ID = (botiz * mTexture#ID.maps[0].#PROP * buffer[aBottomVertex+offset+#INDEX] - edge#EDGE#COMP#ID) * delta;
		/**next TEXTURE_COORDINATE_COMPONENT*/

		// Sub-pixel accuracy
		float subPixel = ((float)Math.ceil(topy) - topy) + aSkip;

		edge#EDGEX += edge#EDGEDeltaX * subPixel;
		edge#EDGEZ += edge#EDGEDeltaZ * subPixel;

		/**for-each TEXTURE_COORDINATE_COMPONENT*/
		edge#EDGE#COMP#ID += edge#EDGEDelta#COMP#ID * subPixel;
		/**next TEXTURE_COORDINATE_COMPONENT*/
	}
	/**next EDGE_INDEX*/


	public void initShader(GeometryBuffer aGeometryBuffer, int aTextureOffset, Material aMaterial, int [] aFrameBuffer, int [] aDepthBuffer)
	{
		/**for-each TEXTURE*/
		mTexture#ID = aGeometryBuffer.getTextures()[aTextureOffset+#ID];
		if (mTexture#ID == null)
		{
			throw new RuntimeException("Texture unit "+(aTextureOffset+#ID)+" is not initialized.");
		}
		/**next TEXTURE*/
		mFrameBuffer = aFrameBuffer;
		mDepthBuffer = aDepthBuffer;
	}


	public void renderScanline(int aBufferOffsetStart)
	{
		if (edgeAX < edgeBX)
		{
			renderScanlineA(aBufferOffsetStart);
		}
		else
		{
			renderScanlineB(aBufferOffsetStart);
		}
	}


	/**for-each EDGE_INDEX*/
	private void renderScanline#EDGE(int aBufferOffsetStart)
	{
		int startX = (int)edge#EDGEX;
		int bufferOffset = aBufferOffsetStart + startX;
		int bufferEnd = aBufferOffsetStart + (int)edge#INVEDGEX;
		int lastSpanOffset = bufferEnd - 16;
		int spanLength;

		// Compute deltas and subtexel accuracy	
		float subTex = (1f - (edge#EDGEX - startX)) * (1 / 16f);
		float width = 16f / (edge#INVEDGEX - edge#EDGEX);

		// Compute Z
		float invertDeltaZ = (edge#INVEDGEZ - edge#EDGEZ) * width;
		float invertZ = edge#EDGEZ + invertDeltaZ * subTex;
		float startZ = 65536f / invertZ;
		float endZ = 65536f / edge#INVEDGEZ;
		int fragZ = (int)startZ;
		int deltaZ;

		/**for-each TEXTURE_COORDINATE_COMPONENT*/
		// Compute #COMP#ID
		float invertDelta#COMP#ID = (edge#INVEDGE#COMP#ID - edge#EDGE#COMP#ID) * width;
		float invert#COMP#ID = edge#EDGE#COMP#ID + invertDelta#COMP#ID * subTex;
		int tex#COMP#ID = (int)(invert#COMP#ID * startZ);
		int delta#COMP#ID;
		/**next TEXTURE_COORDINATE_COMPONENT*/

		Texture2D.TextureData tempTex;

		// Draw scanline
		while (bufferOffset < bufferEnd)
		{
			// Compute sub-span
			if (bufferOffset < lastSpanOffset)
			{
				invertZ += invertDeltaZ;
				/**for-each TEXTURE_COORDINATE_COMPONENT*/
				invert#COMP#ID += invertDelta#COMP#ID;
				/**next TEXTURE_COORDINATE_COMPONENT*/

				spanLength = 16;
				float tempZ = 65536f / invertZ;

				deltaZ = ((int)tempZ - fragZ) >> 4;
				/**for-each TEXTURE_COORDINATE_COMPONENT*/
				delta#COMP#ID = ((int)(invert#COMP#ID * tempZ) - tex#COMP#ID) >> 4;
				/**next TEXTURE_COORDINATE_COMPONENT*/
			}
			else
			{
				spanLength = bufferEnd - bufferOffset;
				float invSpanLength = DIVCONSTANTS[spanLength];

				deltaZ = (int)((endZ -  fragZ) * invSpanLength);
				/**for-each TEXTURE_COORDINATE_COMPONENT*/
				delta#COMP#ID = (int)((edge#INVEDGE#COMP#ID * endZ - tex#COMP#ID) * invSpanLength);
				/**next TEXTURE_COORDINATE_COMPONENT*/
			}

			/**for-each TEXTURE*/
			int texLevel#ID = BASE2LOOKUP[Math.max(Math.abs(deltaU#ID), Math.abs(deltaV#ID)) >> (16 + 1)];
			tempTex = mTexture#ID.maps[Math.min(texLevel#ID,mTexture#ID.maps.length-1)];
			int [] texMap#ID = tempTex.pixels;
			int texShiftU#ID = 16 + texLevel#ID;
			int texShiftV#ID = 16 + texLevel#ID - BASE2LOOKUP[tempTex.width];
			int texMaskU#ID = (tempTex.width  - 1) << (16 + texLevel#ID);
			int texMaskV#ID = (tempTex.height - 1) << (16 + texLevel#ID);
			/**next TEXTURE*/

			// Draw sub-span
			do
			{
/**value-of PIXEL_SHADER_MAIN*/

				fragZ += deltaZ;
				/**for-each TEXTURE_COORDINATE_COMPONENT*/
				tex#COMP#ID += delta#COMP#ID;
				/**next TEXTURE_COORDINATE_COMPONENT*/
				bufferOffset++;
			}
			while (--spanLength > 0);
		}

		// Iterate edges
		edgeAX += edgeADeltaX;
		edgeAZ += edgeADeltaZ;
		edgeBX += edgeBDeltaX;
		edgeBZ += edgeBDeltaZ;
		/**for-each TEXTURE_COORDINATE_COMPONENT*/
		edgeA#COMP#ID += edgeADelta#COMP#ID;
		edgeB#COMP#ID += edgeBDelta#COMP#ID;
		/**next TEXTURE_COORDINATE_COMPONENT*/
	}
	/**next EDGE_INDEX*/
}